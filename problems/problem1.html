<!DOCTYPE html>
<html lang="en">
<head>
    <title>CPSC 487/587</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.3.0/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quaternion@1.5.1/quaternion.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/numeric@1.2.6/numeric-1.2.6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import {get_default_lil_gui, ThreeEngine, refresh_displays} from "../js/utils/utils_three.js";
    import {B1Z1Robot, XArm7Robot} from "../js/utils/utils_robot.js";
    import {add_matrix_matrix, mul_matrix_matrix, mul_matrix_scalar} from "../js/utils/utils_math.js";
    import {z_up_set_object_pose_from_SE3_matrix} from "../js/utils/utils_three.js";

    // todo: create a visualization that demonstrates your knowledge of forward kinematics on a robot model.
    // todo: The "default" assignment is to recreate this visualization:
    // todo: https://yale-cpsc-487-587-internal-djrakita-c95fa6c3239a481a48d29a6b0fd.gitlab.io/html/unit4_visualizations/fk.html
    // todo: or this visualization:
    // todo: https://yale-cpsc-487-587-internal-djrakita-c95fa6c3239a481a48d29a6b0fd.gitlab.io/html/unit4_visualizations/fk2.html
    // todo: however, feel free to deviate from this if you want to.
    // todo: I will be adding information to the class wiki on important properties and subroutines regarding the robot
    // todo: object created for this class.  If you have questions, refer to that wiki or ask me over slack.

    let engine = ThreeEngine.new_default_3d();

    // if you want to use the XArm7 robot:
    //let robot = new XArm7Robot();

    // or, if you want to use the B1Z1 robot, comment the previous robot and uncomment this line:
    let robot = new B1Z1Robot();

    // this will spawn all of the robot's links at the origin
    robot.spawn_robot(engine);

    let joints = robot.joints;
    let links = robot.links;
    let kh = robot.kinematic_hierarchy;
    console.log(robot);

    // create ui
    let gui = get_default_lil_gui();
    
    // DoFs from joint types
    let dof_settings = {};
    joints.forEach(j =>{
        let num_dof = j.joint_num_dofs
        if (num_dof == 1){
            if (j.joint_type_string == "revolute"){
                //console.log(j);
                // revolute
                let key = "DOF" + j.dof_idx + ": " + j.joint_name;
                let minVal = 0;
                if (j.upper_bound < minVal){
                    minVal = j.upper_bound;
                }
                if (j.lower_bound > minVal){
                    minVal = j.lower_bound;
                }
                dof_settings[key] = { value: minVal, min: j.lower_bound, max: j.upper_bound };
            }
        }
        else {
            if (j.joint_type_string == "floating"){
                //console.log("hey");
                //console.log(j.rotation_dof_idxs);
                //console.log(j);

                // floating base
                j.rotation_dof_idxs.forEach(id =>{
                    let key = "DOF" + id + ": " + j.joint_name;
                    dof_settings[key] = { value: 0, min: -Math.PI, max: Math.PI };
                });
                j.translation_dof_idxs.forEach(id =>{
                    let key = "DOF" + id + ": " + j.joint_name;
                    dof_settings[key] = { value: 0, min: -1.0, max: 1.0 };
                });
            }
        }
    });
    let dof_folder = gui.addFolder("DOFs");
    Object.keys(dof_settings).forEach(key =>{
        dof_folder.add(dof_settings[key], 'value', dof_settings[key].min, dof_settings[key].max).name(key);
    });
    // Actions
    let actions = {
        reset: function(){
            Object.keys(dof_settings).forEach(key =>{
                dof_settings[key].value = 0;
            });
            refresh_displays(gui)
        }
    };
    let action_folder = gui.addFolder("Actions");
    action_folder.add(actions, 'reset').name("Reset");
    // Links
    let link_settings = {};
    links.forEach(l =>{
        let key = "Link" + l.link_idx + ": " + l.link_name;
        link_settings[key] = false;
    });
    let link_folder = gui.addFolder("Links");
    Object.keys(link_settings).forEach(key =>{
        link_folder.add(link_settings, key)
    });
    // link actions
    let link_actions = {
        select: function(){
            Object.keys(link_settings).forEach(key =>{
                link_settings[key] = true;
            });
            refresh_displays(gui)
        },
        deselect: function(){
            Object.keys(link_settings).forEach(key =>{
                link_settings[key] = false;
            });
            refresh_displays(gui)
        }
    };
    action_folder.add(link_actions, "select").name("Select All Frames");
    action_folder.add(link_actions, "deselect").name("Deselect All Frames");


    // Revolute
    function getRevoluteTv(axis, value){
        let a = axis[0], b = axis[1], c = axis[2];
        let m = [[0, -c, b], [c, 0, -a], [-b, a, 0]];
        let m2 = mul_matrix_matrix(m, m);
        let i = [[1,0,0],[0,1,0],[0,0,1]];
        let exp = add_matrix_matrix(i, mul_matrix_scalar(m, Math.sin(value)))
        exp = add_matrix_matrix(exp, mul_matrix_scalar(m2, (1-Math.cos(value))));

        // turn into SE(3)
        let Tv = [
            [exp[0][0], exp[0][1], exp[0][2], 0],
            [exp[1][0], exp[1][1], exp[1][2], 0],
            [exp[2][0], exp[2][1], exp[2][2], 0],
            [0, 0, 0, 1],
        ];
        return Tv;
    }

    // Floating
    function getFloatingTv(rv, tv){
        // get exp
        let beta = Math.sqrt(rv[0]*rv[0] + rv[1]*rv[1] + rv[2]*rv[2]);
        let Tv;
        if (beta == 0){
            // do not rotate
            Tv = [
                [1, 0, 0, tv[0]],
                [0, 1, 0, tv[1]],
                [0, 0, 1, tv[2]],
                [0, 0, 0, 1],
            ];
        }
        else{
            let axis = mul_matrix_scalar(rv, (1/beta));
            let a = axis[0], b = axis[1], c = axis[2];
            let m = [[0, -c, b], [c, 0, -a], [-b, a, 0]];
            let m2 = mul_matrix_matrix(m, m);
            let i = [[1,0,0],[0,1,0],[0,0,1]];
            let exp = add_matrix_matrix(i, mul_matrix_scalar(m, Math.sin(beta)))
            exp = add_matrix_matrix(exp, mul_matrix_scalar(m2, (1-Math.cos(beta))));
            //console.log(exp);
            Tv = [
                [exp[0][0], exp[0][1], exp[0][2], tv[0]],
                [exp[1][0], exp[1][1], exp[1][2], tv[1]],
                [exp[2][0], exp[2][1], exp[2][2], tv[2]],
                [0, 0, 0, 1],
            ];
        }
        //console.log("floating");
        //console.log(Tv);
        return Tv;
    }

    /*
    console.log("debug!!!");
    console.log(kh);
    kh.forEach(layer => {
        layer.forEach(link_idx => {
            //console.log(link_idx);
            //console.log(links[link_idx]);
            let curr_link = links[link_idx];
            //console.log(curr_link);
            let parent_link_idx = curr_link.parent_link_idx;
            let parent_joint_idx = curr_link.parent_joint_idx;
            let curr_joint = joints[parent_joint_idx];
            //console.log(curr_joint);
            //console.log(curr_joint.joint_type_string);
        });
    });
    */

    export function forward_kinematics(state) {
        // for links
        let output_poses = [];
        for(let i = 0; i < links.length; i++) {
	        output_poses.push( 
                // SE(3) identity matrix
                [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]
            );
        }

        kh.forEach(layer => {
            layer.forEach(link_idx => {
                let curr_link = links[link_idx];
                let parent_link_idx = curr_link.parent_link_idx;
                let parent_joint_idx = curr_link.parent_joint_idx;
                if (parent_joint_idx != null)
                {
                    let curr_joint = joints[parent_joint_idx];
                    let joint_type = curr_joint.joint_type_string;
                    
                    // get parent pose
                    let curr_pose = output_poses[parent_link_idx];

                    // constant transformation
                    let T_c = curr_joint.xyz_rpy_SE3_matrix;
                    curr_pose = mul_matrix_matrix(curr_pose, T_c);
                
                    // variable transformation
                    // default to fixed joint
                    let T_v = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];
                    if (joint_type === 'revolute') {
                        let joint_value = state[curr_joint.dof_idx];
                        let axis = curr_joint.axis
                        T_v = getRevoluteTv(axis, joint_value);
                    } 
                    else if (joint_type === 'floating') {
                        let rd = curr_joint.rotation_dof_idxs;
                        let td = curr_joint.translation_dof_idxs;

                        let rv = [ state[rd[0]], state[rd[1]], state[rd[2]] ];
                        let tv = [ state[td[0]], state[td[1]], state[td[2]] ];

                        T_v = getFloatingTv(rv, tv);
                    }
                    
                    curr_pose = mul_matrix_matrix(curr_pose, T_v);
                    output_poses[link_idx] = curr_pose;
                    //console.log(curr_pose);
                } else {
                    output_poses[link_idx] = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];
                }
                
            });
        });
        return output_poses;
    }
    
    let xaxis = [[0.05],[0],[0],[1]];
    let yaxis = [[0],[0.05],[0],[1]];
    let zaxis = [[0],[0],[0.05],[1]];

    engine.animation_loop( ()  => {
        // grab dof values from gui
        let state = [];
        Object.keys(dof_settings).forEach(key =>{
            state.push(dof_settings[key].value);
        });

        let link_visible = [];
        Object.keys(link_settings).forEach(key =>{
            link_visible.push(link_settings[key]);
        });

        //console.log(state);
        let poses = forward_kinematics(state);
        
        let linkI = 0;
        // apply transform to meshes
        robot.link_to_mesh_idxs_mapping.forEach(link_idxs => {
            link_idxs.forEach(idx => {
                z_up_set_object_pose_from_SE3_matrix(engine.mesh_objects[idx], poses[linkI]);
            });
            linkI++;
        });

        // show links
        for (let i = 0; i < link_visible.length; i++){
            if (link_visible[i]){
                let t = poses[i];
                
                // transform with t
                let o = [t[0][3], t[1][3], t[2][3]];
                //mul_matrix_matrix(t, origin);
                let x = mul_matrix_matrix(t, xaxis);
                let y = mul_matrix_matrix(t, yaxis);
                let z = mul_matrix_matrix(t, zaxis);
                //o = [o[0], o[1], o[2]];

                // draw
                engine.draw_debug_line(o, [x[0], x[1], x[2]], true, 0.002, "rgb(255, 0, 0)", 1);
                engine.draw_debug_line(o, [y[0], y[1], y[2]], true, 0.002, "rgb(0, 255, 0)", 1);
                engine.draw_debug_line(o, [z[0], z[1], z[2]], true, 0.002, "rgb(0, 0, 255)", 1);

            }
            
        }


    });
        

</script>
</body>
</html>